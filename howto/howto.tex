% howto/howto.tex

\QuickQuizChapter{chp:How To Use This Book}{How To Use This Book}

이 책의 목적은 당신이 shared-memory parallel machine 을 정확성을 해치지
않으면서 프로그램하는 것을 돕는 것입니다.\footnote{
	또는, 좀 더 정확히는, 병렬성 없는 프로그래밍에 비해 정확성을 덜
	해치면서요.}
우린 이 책의 디자인 원칙이 당신이 적어도 몇몇 병렬 프로그래밍의 함정들은
피하는데 도움을 주길 바랍니다.
즉, 당신은 이 책을 완성된 성당이라기보단 새로 건물을 지을 토대라고 생각해야
합니다.
이를 따르기로 한다면, 당신의 임무는 이 신나는 병렬 프로그래밍 세계의 ---결국엔
이 책을 구식으로 만들게 될---발전을 돕는겁니다.
병렬 프로그래밍은 일부 사람들이 말하는 것처럼 어렵지 않고, 우리는 이 책이
당신의 병렬 프로그래밍 프로젝트를 더 쉽고 재밌게 만들길 바랍니다.
\iffalse

The purpose of this book is to help you program
shared-memory parallel machines without risking your sanity.\footnote{
	Or, perhaps more accurately, without much greater risk to your
	sanity than that incurred by non-parallel programming.
	Which, come to think of it, might not be saying all that much.}
We hope that this book's design principles will help you avoid at least some
parallel-programming pitfalls.
That said, you should think of this book as a foundation on which to build,
rather than as a completed cathedral.
Your mission, if you choose to accept, is to help make further progress
in the exciting field of parallel programming---progress that will
in time render this book obsolete.
Parallel programming is not as hard as some say, and we hope
that this book makes your parallel-programming projects easier and
more fun.
\fi

짧게 말해서, 병렬 프로그래밍이 일단 과학, 연구, 뭔가 대단한 과제에 적용되면
곧바로 엔지니어링 문제가 되어버립니다.
따라서 우리는 병렬 프로그래밍에서 하는 특정 작업들을 알아보고, 그것들을 어떻게
해결하는지 설명합니다.
그러한 해결책들은 놀라울정도로 흔한 경우들에서 자동화조차도 가능합니다.
\iffalse

In short, where parallel programming once focused on science, research,
and grand-challenge projects, it is quickly becoming an engineering
discipline.
We therefore examine specific parallel-programming tasks
and describe how to approach them.
In some surprisingly common cases, they can even be automated.
\fi

이 책은 성공적 병렬 프로그래밍 프로젝트에 숨어있는 엔지니어링 비법들을 알려주는
것이 새로운 세대의 병렬성 해커들을 느리고 고통스럽게 오래된 바퀴를 다시
만들어내는 대신, 그들의 에너지와 창의성을 새로운 영역에 집중하도록 도울 수 있길
바라는 마음으로 쓰였습니다.
우린 병렬 프로그래밍이 당신에게 재미와 흥분, 그리고 도전을 그것이 우리에게도
가져다 주었던 만큼은 가져다 주길 바랍니다.
\iffalse

This book is written in the hope that presenting the engineering
discipline underlying successful
parallel-programming projects will free a new generation of parallel hackers
from the need to slowly and painstakingly reinvent old wheels, enabling
them to instead focus their energy and creativity on new frontiers.
We sincerely hope that parallel programming brings you at least as
much fun, excitement, and challenge that it has brought to us!
\fi

\section{Roadmap}
\label{sec:howto:Roadmap}

이 책은 극소수의 영역에만 적용 가능한 최적의 알고리즘의 모음이라기보다는 폭넓게
적용될 수 있고 많이 사용된 디자인 테크닉들을 소개하는 안내서입니다.
여러분은 지금 Chapter~\ref{chp:How To Use This Book}을 읽고 있습니다, 알고
있겠지만요.
Chapter~\ref{chp:Introduction} 은 병렬 프로그래밍에 대해 전반적으로 간단히
살펴봅니다.
\iffalse

This book is a handbook of widely applicable and heavily
used design techniques, rather than
a collection of optimal algorithms with tiny areas of applicability.
You are currently reading Chapter~\ref{chp:How To Use This Book}, but
you knew that already.
Chapter~\ref{chp:Introduction} gives a high-level overview of parallel
programming.
\fi

Chapter~\ref{chp:Hardware and its Habits} 는 shared-memory parallel hardware 에
대해 소개합니다.
어쨌든, 여러분이 코드가 동작하게 될 하드웨어에 대해 모르면 병렬성 있는 좋은
코드를 작성하기가 어렵습니다.
하드웨어는 계속 발전할테니, 이 챕터는 항상 시대에 뒤쳐질겁니다.
따라서 우리는 내용을 최신으로 유지하기 위해 최선을 다할겁니다.
Chapter~\ref{chp:Tools of the Trade} 는 이어서 shared-memory 병렬 프로그래밍의
기본을 매우 간략히 소개합니다.
\iffalse

Chapter~\ref{chp:Hardware and its Habits} introduces shared-memory
parallel hardware.
After all, it is difficult to write good parallel code unless you
understand the underlying hardware.
Because hardware constantly evolves, this chapter will always be
out of date.
We will nevertheless do our best to keep up.
Chapter~\ref{chp:Tools of the Trade} then provides a very brief overview
of common shared-memory parallel-programming primitives.
\fi

Chapter~\ref{chp:Counting} 에서는 상상할 수 있는 가장 간단한 문제인 카운팅을
병렬화 하는 작업에 대해 자세히 알아봅니다.
대부분은 카운팅에 대해서는 잘 알고 있을테니, 이 챕터에서는 보다 흔한 컴퓨터
사이언스에서의 문제들에 정신을 뺏기지 않고 병렬 프로그래밍 이슈에 대해서만
집중할 수 있을 겁니다.
제 생각에는 이 챕터가 병렬 프로그래밍 수업에서 가장 많이 활용되곤 합니다.
\iffalse

Chapter~\ref{chp:Counting} takes an in-depth look at parallelizing
one of the simplest problems imaginable, namely counting.
Because almost everyone has an excellent grasp of counting, this chapter
is able to delve into many important parallel-programming issues without
the distractions of more-typical computer-science problems.
My impression is that this chapter has seen the greatest use in
parallel-programming coursework.
\fi

Chapter~\ref{cha:Partitioning and Synchronization Design} 에서는
Chapter~\ref{chp:Counting} 에서 파악한 문제들을 해결하는 설계 레벨의 방법들을
소개합니다.
가능할때엔 병렬성을 설계 레벨에서 해결하는 것이 중요합니다:
Dijkstra~\cite{Dijkstra:1968:LEG:362929.362947} 의 말을 바꿔쓰자면, ``개선된
병렬성은 최적이 아닌 것으로 본다''~\cite{PaulEMcKenney2012HOTPARsuboptimal}.
\iffalse

Chapter~\ref{cha:Partitioning and Synchronization Design}
introduces a number of design-level methods of addressing the issues
identified in Chapter~\ref{chp:Counting}.
It turns out that it is important to address parallelism at
the design level when feasible:
To paraphrase Dijkstra~\cite{Dijkstra:1968:LEG:362929.362947},
``retrofitted parallelism considered grossly
suboptimal''~\cite{PaulEMcKenney2012HOTPARsuboptimal}.
\fi

이어지는 세개의 챕터는 세개의 중요한 동기화 방법을 각각 설명합니다.
Chapter~\ref{chp:Locking} 에서는 적어도 2014년에 와서는 제품 수준의 병렬
프로그래밍에 있어 가장 많이 사용되지도 않고, 일반적으로 병렬 프로그래밍의 가장
악랄한 악당으로 여겨지는 락킹에 대해 알아봅니다.
Chapter~\ref{chp:Data Ownership} 는 과소평가되곤 하지만 실제로는 놀랍도록 여러
분야에 사용 가능하고 강력한 방법인 데이터 소유권에 대해 알아봅니다.
마지막으로 Chapter~\ref{chp:Deferred Processing} 에서는 레퍼런스 카운팅, 해저드
포인터, 순차적 락킹, 그리고 RCU 를 포함한 deferred-processing 메커니즘들을
소개합니다.
\iffalse

The next three chapters examine three important approaches to
synchronization.
Chapter~\ref{chp:Locking} covers locking, which in 2014 is not only the
workhorse of production-quality parallel programming, but is also widely
considered to be parallel programming's worst villain.
Chapter~\ref{chp:Data Ownership} gives a brief overview of data ownership,
an often overlooked but remarkably pervasive and powerful approach.
Finally, Chapter~\ref{chp:Deferred Processing} introduces a number of
deferred-processing mechanisms, including reference counting,
hazard pointers, sequence locking, and RCU.
\fi

Chapter~\ref{chp:Data Structures} 에서는 앞에서 배운 내용들을 해시 테이블에
적용해 봅니다.
해시 테이블은 그 훌륭한 데이터 분리성으로 인해 널리 사용되고 있고, 때문에
(보통은) 훌륭한 성능과 확장성을 보입니다.
\iffalse

Chapter~\ref{chp:Data Structures} applies the lessons of previous
chapters to hash tables, which are heavily used due
to their excellent partitionability, which (usually) leads to excellent
performance and scalability.
\fi

많은 사람들이 그들의 슬픔에서 배웠듯이, validation (실증) 없이 이루어지는 병렬
프로그래밍은 비참한 실패로의 분명한 지름길입니다.
Chapter~\ref{chp:Validation} 에서는 다양한 테스트 방법을 다룹니다.
물론 모든 부분에 대해 프로그램의 신뢰성을 테스트 하는 것은 불가능합니다.
따라서 Chapter~\ref{chp:Formal Verification} 에서는 몇개의 실용적인 형식적
검증 (formal verification) 방법에 대해 간단히 다룹니다.
\iffalse

As many have learned to their sorrow, parallel programming without
validation is a sure path to abject failure.
Chapter~\ref{chp:Validation} covers various forms of testing.
It is of course impossible to test reliability into your program
after the fact, so Chapter~\ref{chp:Formal Verification}
follows up with a brief overview of a couple of practical approaches to
formal verification.
\fi

Chapter~\ref{chp:Putting It All Together} 에서는 적당한 크기의 병렬 프로그래밍
문제들을 다룹니다.
이런 문제들의 난이도는 다양하지만 앞 챕터들의 내용을 이해한 사람에게는 적당할
겁니다.
\iffalse

Chapter~\ref{chp:Putting It All Together}
contains a series of moderate-sized parallel programming problems.
The difficulty of these problems vary, but should be appropriate for
someone who has mastered the material in the previous chapters.
\fi

Chapter~\ref{sec:advsync:Advanced Synchronization} 에서는 메모리 배리어와
non-blocking 동기화를 포함한 고급 동기화 방법을 알아봅니다.
이어지는 Chapter~\ref{chp:Ease of Use} 는 몇몇 ease-of-use 기법들을
이야기합니다.
마지막으로, Chapter~\ref{chp:Conflicting Visions of the Future} 에서는 공유
메모리 병렬 시스템 설계, 소프트웨어 / 하드웨어 트랜잭셔널 메모리, 그리고
병렬성을 위한 함수형 프로그래밍을 포함해 몇몇 가능할 법한 미래의 방향에 대해
알아봅니다.
\iffalse

Chapter~\ref{sec:advsync:Advanced Synchronization}
looks at advanced synchronization methods, including memory barriers
and non-blocking synchronization, while
Chapter~\ref{chp:Parallel Real-Time Computing}
looks at the nascent field of parallel real-time computing.
Chapter~\ref{chp:Ease of Use} follows up with some ease-of-use advice.
Finally, Chapter~\ref{chp:Conflicting Visions of the Future}
looks at a few possible future directions, including
shared-memory parallel system design, software and hardware transactional
memory, and functional programming for parallelism.
\fi

이 책의 끝에는 여러개의 부록이 있습니다.
그 중 가장 인기 있는건 메모리 배리어에 대해 다루고 있는
Appendix~\ref{chp:app:whymb:Why Memory Barriers?} 일 겁니다.
Appendix~\ref{chp:Answers to Quick Quizzes} 는 다음 섹션에서 이야기할, Quick
Quizz 들의 답을 담고 있습니다.
\iffalse

This chapter is followed by a number of appendices.
The most popular of these appears to be
Appendix~\ref{chp:app:whymb:Why Memory Barriers?},
which covers memory barriers.
Appendix~\ref{chp:Answers to Quick Quizzes}
contains the answers to the infamous Quick Quizzes, which are discussed in
the next section.
\fi

\section{Quick Quizzes}
\label{sec:howto:Quick Quizzes}

``Quick quizzes'' 는 이 책 전반에 걸쳐 여기저기서 나오고, 그에 대한 답은
페이지~\pageref{chp:Answers to Quick Quizzes} 부터 시작하는
Appendix~\ref{chp:Answers to Quick Quizzes} 에서 볼 수 있습니다.
그 중 일부는 그 퀴즈가 제출된 곳의 내용에 기반하지만, 몇몇은 그 섹션 이외의
내용에 대해서도 생각해야 할 거고, 일부는 당신이 알고 있는 모든 내용을 필요로 할
수도 있습니다.
최대한 노력했다는 가정 하에, 당신이 이 책으로부터 얻을 수 있는 것은 당신이 배운
내용을 얼마나 실제로 응용하는지에 달려있습니다.  따라서, 답을 보기 전에 퀴즈를
풀기 위해 많은 노력을 기울인 독자는 향상된 병렬 프로그래밍에 대한 이해와 함께
그들의 노력이 결실로 돌아옴을 알 수 있을 것입니다.

\iffalse
``Quick quizzes'' appear throughout this book, and the answers may
be found in
Appendix~\ref{chp:Answers to Quick Quizzes} starting on
page~\pageref{chp:Answers to Quick Quizzes}.
Some of them are based on material in which that quick quiz
appears, but others require you to think beyond that section, and,
in some cases, beyond the realm of current knowledge.
As with most endeavors, what you get out of this book is largely
determined by what you are willing to put into it.
Therefore, readers who make a genuine effort to solve a quiz before
looking at the answer
find their effort repaid handsomely with increased understanding
of parallel programming.
\fi

\QuickQuiz{}
	이 Quick Quiz 들의 답은 어디에 있을까요?

\iffalse
	Where are the answers to the Quick Quizzes found?
\fi
\QuickQuizAnswer{
	페이지~\pageref{chp:Answers to Quick Quizzes} 에서 시작하는
	Appendix~\ref{chp:Answers to Quick Quizzes}.

\iffalse
	In Appendix~\ref{chp:Answers to Quick Quizzes} starting on
	page~\pageref{chp:Answers to Quick Quizzes}.
\fi

	쉽죠?
\iffalse
	Hey, I thought I owed you an easy one!
\fi
} \QuickQuizEnd

\QuickQuiz{}
	몇몇 퀴즈는 저자의 입장이 아니라 독자의 입장에서 쓰인 것 같은데요.
	그런 의도가 맞나요?

\iffalse
	Some of the Quick Quiz questions seem to be from the viewpoint
	of the reader rather than the author.
	Is that really the intent?
\fi
\QuickQuizAnswer{
	실제로 그렇답니다!  많은 질문들은 Paul E. Mckenny 가 이 내용들을 다루는
	수업을 듣는 학생이었다면 질문했을 법한 것들입니다.  Paul 은 이 내용들을
	교수님으로부터가 아니라 병렬 하드웨어와 소프트웨어로부터 배웠다는
	내용도 짚어둬야 할 것 같네요.  Paul 의 경험에 의하면, 교수님들은 Watson
	같은 실제 병렬 시스템과는 달리 말로 이야기되는 문제에 대해 답을 주려
	하곤 합니다.  물론, 어떤 교수님들이나 병렬 시스템들이 이런 종류의
	문제들에 대해 가장 유용한 답을 주는지에 대해서는 많은 토론이
	가능하겠습니다만, 지금은 일단 실제 교수님들과 병렬 시스템들에 따라
	그들이 주는 답의 유용성이 다를 수 있다는 점만 동의하고 넘어갑시다.

\iffalse
	Indeed it is!
	Many are questions that Paul E. McKenney would probably have
	asked if he was a novice student in a class covering this material.
	It is worth noting that Paul was taught most of this material by
	parallel hardware and software, not by professors.
	In Paul's experience, professors are much more likely to provide
	answers to verbal questions than are parallel systems,
	Watson notwithstanding.
	Of course, we could have a lengthy debate over which of professors
	or parallel systems provide the most useful answers to these sorts
	of questions,
	but for the time being let's just agree that usefulness of
	answers varies widely across the population both of professors
	and of parallel systems.
\fi

	그 외의 퀴즈들은 컨퍼런스 발표 중에, 그리고 이 책에서 다루는 내용을
	다루는 수업 중에 받은 실제 질문과 유사합니다.
	그리고 일부 퀴즈는 저자의 관점에서 쓰이기도 했습니다.

\iffalse
	Other quizzes are quite similar to actual questions that have been
	asked during conference presentations and lectures covering the
	material in this book.
	A few others are from the viewpoint of the author.
\fi
} \QuickQuizEnd

\QuickQuiz{}
	전 퀵 퀴즈를 좋아하지 않아요.
	어떡하죠?

\iffalse
	These Quick Quizzes are just not my cup of tea.
	What can I do about it?
\fi
\QuickQuizAnswer{

여기 몇가지 전략이 있습니다:

\iffalse
Here are a few possible strategies:
\fi

\begin{enumerate}
\item	그냥 퀵 퀴즈를 무시하고 책을 읽으세요.  퀵 퀴즈의 흥미로운 내용들을
	놓치게 되겠지만 이 책의 퀵 퀴즈를 제외한 부분도 훌륭한 내용을 많이 담고
	있습니다.  만약 당신의 목표가 일반적인 내용에 대한 이해를 얻는 것이거나
	이 책을 통해 특정 문제에 대한 해결책을 찾는 것이라면 충분히 합리적인
	접근법입니다.

\iffalse
\item	Just ignore the Quick Quizzes and read the rest of
	the book.
	You might miss out on the interesting material in
	some of the Quick Quizzes, but the rest of the book
	has lots of good material as well.
	This is an eminently reasonable approach if your main
	goal is to gain a general understanding of the material
	or if you are skimming through to book to find a
	solution to a specific problem.
\fi

\item	퀵 퀴즈가 집중을 방해하지만 무시하기엔 중요하다고 생각한다면, 언제든 이
	책의 소스를 git 저장소에서 클론할 수 있음을 기억하세요.
	그러고나서 \path{Makefile} 과 \path{qqz.sty} 를 수정해서 퀵 퀴즈가 PDF 에서
	사라지게 할 수 있습니다.
	또는, 해당 파일들을 수정해서 답변이 문제 바로 아래 나오도록 수정할 수도
	있습니다.

\iffalse
\item	If you find the Quick Quizzes distracting but impossible
	to ignore, you can always clone the \LaTeX{} source for
	this book from the git archive.
	You can then modify \path{Makefile} and \path{qqz.sty} to eliminate
	the Quick Quizzes from the PDF output.
	Alternatively, you could modify these two files so as
	to pull the answers inline, immediately following
	the questions.
\fi

\item	당신의 답을 구하느라 너무 많은 시간을 보내지 말고 곧바로 답을 보세요.
	현재 퀵 퀴즈의 답이 당신이 해결하려는 문제의 핵심을 쥐고 있는 게
	아니라면 이것도 합리적인 접근법입니다.  또한, 당신이 원하는게 해당
	내용에 대한 깊은 이해이지, 새로이 병렬성을 활용한 해결책을 맨바닥부터
	만들려 하는게 아닌 경우에도 이는 합리적인 접근법입니다.

\iffalse
\item	Look at the answer immediately rather than investing
	a large amount of time in coming up with your own
	answer.
	This approach is reasonable when a given Quick Quiz's
	answer holds the key to a specific problem you are
	trying to solve.
	This approach is also reasonable if you want a somewhat
	deeper understanding of the material, but when you do not
	expect to be called upon to generate parallel solutions given
	only a blank sheet of paper.
\fi
\end{enumerate}

2016 년 중반부터 퀵 퀴즈는 답으로, 답은 퀵 퀴즈로 링크가 되어 있습니다.
답으로 이동하기 위해서는 ``Quick Quiz'' 나 작은 검정 네모를 클릭하세요.
답에서 퀴즈의 시작으로 가기 위해서는 답 시작점이나 작은 검정 네모를, 퀴즈의
끝으로 가려면 작은 하얀 네모를 클릭하세요.
\iffalse

Note that as of mid-2016 the quick quizzes are hyperlinked
to the answers and vice versa.
Click either the ``Quick Quiz'' heading or the small black square
to move to the beginning of the answer.
From the answer, click on the heading or the small black square to
move to the beginning of the quiz, or, alternatively, click on the
small white square at the end of the answer to move to the end of the
corresponding quiz.
\fi
} \QuickQuizEnd

간략히 정리하자면, 당신이 해당 내용에 대해 깊은 이해가 필요하다면, 어느 정도의
시간은 퀵 퀴즈의 답을 구하는데 사용할 필요가 있습니다.
가만히 내용을 읽기만 하는 것도 물론 의미있습니다만, 완벽한 문제 해결 능력을
갖는 것은 실질적인 문제를 풀어보는 것도 필요로 합니다.

\iffalse
In short, if you need a deep
understanding of the material, then you should invest some time
into answering the Quick Quizzes.
Don't get me wrong, passively reading the material can be quite
valuable, but gaining full problem-solving capability really
does require that you practice solving problems.
\fi

저는 이 깨달음을 저의 늦깎이 박사 과정에서 힘들게 얻었습니다.  저는 제게 익숙한
주제를 공부했는데, 제가 해당 챕터의 연습문제 중에 제가 곧바로 머리 속에서 답할
수 있는 내용이 얼마 안된다는 사실에 놀랐습니다.\footnote{ 아마 그래서 제
교수님들은 제가 그 수업을 포기하지 못하게 하셨다고 생각합니다} 저 스스로를 그
문제들을 풀도록 강제하는 것은 해당 내용에 대한 제 기억력을 매우 높였습니다.
따라서 저는 이 퀵 퀴즈들에 대해 제가 스스로 하지 않았던 것을 여러분에게
강요하고 있지는 않아요!

마지막으로, 가장 흔한 학습 장애는 당신이 이미 알고 있다고 생각하는 것입니다.
퀵 퀴즈들은 그걸 낫게 하는데 매우 효과적일 수 있습니다.

\iffalse
I learned this the hard way during coursework for my late-in-life
Ph.D.
I was studying a familiar topic, and was surprised at how few of
the chapter's exercises I could answer off the top of my head.\footnote{
	So I suppose that it was just as well that my professors refused
	to let me waive that class!}
Forcing myself to answer the questions greatly increased my
retention of the material.
So with these Quick Quizzes I am not asking you to do anything
that I have not been doing myself!

Finally, the most common learning disability is thinking that
you already know.
The quick quizzes can be an extremely effective cure.
\fi

\section{Alternatives to This Book}
\label{sec:Alternatives to This Book}

Knuth 가 깨달았던 것과 같이, 당신의 책의 내용에 끝이 있으려면 그 책의 내용은
어딘가에 집중되어 있어야 합니다.  이 책은 운영체제 커널, 병렬 데이터 관리
시스템, 저수준 라이브러리 등과 같은 소프트웨어 스택의 바닥 쪽에 있는
소프트웨어를 주요 대상으로 두고 공유메모리 기반 병렬 프로그래밍에 중점을
둡니다.
이 책에서 프로그래밍 언어로는 C 언어를 사용합니다.

\iffalse
As Knuth learned, if you want your book to be finite, it must be focused.
This book focuses on shared-memory parallel programming, with an
emphasis on software that lives near the bottom of the software stack,
such as operating-system kernels, parallel data-management systems,
low-level libraries, and the like.
The programming language used by this book is C.
\fi

당신이 병렬성의 다른 분야에 관심있다면, 다른 책을 보는 편이 좋을 겁니다.
만약 그렇다면, 다행히도 여러 좋은 책들이 있습니다:

\iffalse
If you are interested in other aspects of parallelism, you might well
be better served by some other book.
Fortunately, there are many alternatives available to you:
\fi

\begin{enumerate}
\item	보다 학술적이고 정밀하게 병렬 프로그래밍을 다루고 싶다면, Herlihy 와
	Shavit 의 책~\cite{HerlihyShavit2008Textbook}이 당신에게 적합할 겁니다.
	이 책은 추상화된 하드웨어에서 제공하는 원초적 기능들의 조합으로
	시작해서 락킹과 리스트, 큐, 해시 테이블, 그리고 카운터를 포함한 간단한
	자료구조들을 다루고, 마지막으로 트랜잭셔널 메모리를 다룹니다.  Michael
	Scott 의 책~\cite{MichaelScott2013Textbook} 은 비슷한 내용을 보다
	소프트웨어 엔지니어링에 중점을 두어서 접근합니다. 그리고, 제가 알기로는
	최초로 RCU 에 대한 내용의 섹션을 담은 채로 정식으로 학계에 출간된
	최초의 책입니다.

\iffalse
\item	If you prefer a more academic and rigorous treatment of
	parallel programming,
	you might like Herlihy's and Shavit's
	textbook~\cite{HerlihyShavit2008Textbook}.
	This book starts with an interesting combination
	of low-level primitives at high levels of abstraction
	from the hardware, and works its way through locking
	and simple data structures including lists, queues,
	hash tables, and counters, culminating with transactional
	memory.
	Michael Scott's textbook~\cite{MichaelScott2013Textbook}
	approaches similar material with more of a
	software-engineering focus, and, as far as I know, is
	the first formally published academic textbook to include a
	section devoted to RCU.
\fi

\item	당신이 프로그래밍 언어적 실용성 관점에서의 병렬 프로그래밍에 대한
	학술적 처리를 알고 싶다면 Scott 의 책~\cite{MichaelScott2006Textbook}
	의 concurrency (동시성) 챕터를 재밌게 볼 수 있을 겁니다.

\iffalse
\item	If you would like an academic treatment of parallel
	programming from a programming\-/language\-/pragmatics viewpoint,
	you might be interested in the concurrency chapter from Scott's
	textbook~\cite{MichaelScott2006Textbook}
	on programming-language pragmatics.
\fi

\item	객체 지향 패턴 전문가들이 병렬 프로그래밍을 어떻게 취급하는지 C++
	위주로 알고 싶다면 Schmidt 의 POSA
	시리즈~\cite{SchmidtStalRohnertBuschmann2000v2Textbook,
	BuschmannHenneySchmidt2007v4Textbook} 의 Volume~2 와 4 를 읽어봐도 좋을
	겁니다.  특히 Volume 4 는 그 작업물을 도매점 어플리케이션에 적용해본
	내용에 대한 재미있는 챕터들이 있습니다.  이 예제가 얼마나 실제 상황에
	가까운지는 병렬성에 내재된 문제들은 종종 실제 세계의 응용사례에서
	시작된다는 이야기를 하는 ``Partitioning the Big Ball of Mud'' 라는
	제목의 섹션에서 증명되었습니다.

\iffalse
\item	If you are interested in an object-oriented patternist
	treatment of parallel programming focussing on C++,
	you might try Volumes~2 and 4 of Schmidt's POSA
	series~\cite{SchmidtStalRohnertBuschmann2000v2Textbook,
	BuschmannHenneySchmidt2007v4Textbook}.
	Volume 4 in particular has some interesting chapters
	applying this work to a warehouse application.
	The realism of this example is attested to by
	the section entitled ``Partitioning the Big Ball of Mud'',
	wherein the problems inherent in parallelism often
	take a back seat to the problems inherent in getting
	one's head around a real-world application.
\fi

\item	당신이 리눅스 커널 디바이스 드라이버를 다루고 싶다면 Corbet, Rubini,
	그리고 Kroah-Hartman 이 쓴 ``Linux Device
	Drivers''~\cite{CorbetRubiniKroahHartman}, 그리고 Linux Weekly New
	웹사이트 (\url{http://lwn.net/} 를 반드시 봐야 합니다.
	리눅스 커널 내부에 대한 일반적 내용에 대해서는 많은 책과 자료들이
	있습니다.

\iffalse
\item	If you want to work with Linux-kernel device drivers,
	then Corbet's, Rubini's, and Kroah-Hartman's
	``Linux Device Drivers''~\cite{CorbetRubiniKroahHartman}
	is indispensable, as is the Linux Weekly News web site
	(\url{http://lwn.net/}).
	There is a large number of books and resources on
	the more general topic of Linux kernel internals.
\fi

\item	당신의 주요 관심사가 과학 / 기술 분야 컴퓨팅이라면, 그리고 패턴주의자의
	접근방법을 선호한다면, Mattson 의 책~\cite{Mattson2005Textbook} 을 읽어
	보십시오.
	그 책에서는 Java, C/C++, OpenMP, 그리고 MPI 를 다룹니다.
	거기서 이야기하는 패턴들은 첫째로 설계, 다음으로 구현에 매우 집중되어
	있습니다.

\iffalse
\item	If your primary focus is scientific and technical computing,
	and you prefer a patternist approach,
	you might try Mattson et al.'s
	textbook~\cite{Mattson2005Textbook}.
	It covers Java, C/C++, OpenMP, and MPI.
	Its patterns are admirably focused first on design,
	then on implementation.
\fi

\item	당신의 주요 관심사가 과학 / 기술 분야 컴퓨팅이고 GPU, CUDA, 그리고 MPI
	에 관심이 있다면, Norm Matloff 의 `Programming on Parallel
	Machines''~\cite{NormMatloff2013ParProcBook} 을 한번쯤 보세요.
	물론, GPU 제조사들은 추가적인 정보들을 많이 가지고 있습니다~\cite{AMD2017OpenCL,NVidia2017GPGPU,NVidia2017GPGPU-university}.

\iffalse
\item	If your primary focus is scientific and technical computing,
	and you are interested in GPUs, CUDA, and MPI, you
	might check out Norm Matloff's ``Programming on
	Parallel Machines''~\cite{NormMatloff2013ParProcBook}.
	Of course, the GPU vendors have quite a bit of additional
	information~\cite{AMD2017OpenCL,NVidia2017GPGPU,NVidia2017GPGPU-university}.
\fi
\item	POSIX 쓰레드에 관심 있다면, David R.~Butenhof 의
	책~\cite{Butenhof1997pthreads} 을 읽어보세요.  또한, W.~Richard Stevens
	의 책~\cite{WRichardStevens1992} 은 UNIX 와 POSIX 를 다루고, Stewart
	Weiss 의 수업노트~\cite{StewartWeiss2013UNIX} 는 좋은 예제들과 함께
	완전하고 접근 가능한 소개를 제공합니다.
\iffalse

\item	If you are interested in POSIX Threads, you might take
	a look at David R.~Butenhof's book~\cite{Butenhof1997pthreads}.
	In addition,
	W.~Richard Stevens's book~\cite{WRichardStevens1992}
	covers UNIX and POSIX, and Stewart Weiss's lecture
	notes~\cite{StewartWeiss2013UNIX} provide an
	thorough and accessible introduction with a good set of
	examples.
\fi

\item	C++11 에 관심 있다면, Anthony Williams 의 ``C++ Concurrency in Action:
	Practical Multithreading''~\cite{AnthonyWilliams2012} 를 좋아할 수 있을
	겁니다.

\iffalse
\item	If you are interested in C++11, you might like
	Anthony Williams's ``C++ Concurrency in Action: Practical
	Multithreading''~\cite{AnthonyWilliams2012}.
\fi

\item	C++ 에 관심 있지만 Windows 환경에 있다면 Dr. Dobb 의
	잡지~\cite{HerbSutter2008EffectiveConcurrency} 에 실린 Herb Sutter 의
	``Effective Concurrency'' 시리즈를 읽어보세요.
	이 시리즈는 병렬성에의 일반적 접근을 잘 소개합니다.

\iffalse
\item	If you are interested in C++, but in a Windows environment,
	you might try Herb Sutter's ``Effective Concurrency''
	series in
	Dr. Dobbs Journal~\cite{HerbSutter2008EffectiveConcurrency}.
	This series does a reasonable job of presenting a
	commonsense approach to parallelism.
\fi

\item	Intel Threading Building Blocks 를 사용해 보고 싶다면, James Reinder 의
	책~\cite{Reinders2007Textbook} 이 아마 찾으시는 책일 겁니다.

\iffalse
\item	If you want to try out Intel Threading Building Blocks,
	then perhaps James Reinders's book~\cite{Reinders2007Textbook}
	is what you are looking for.
\fi

\item	다양한 멀티 프로세서 시스템의 하드웨어 캐시 구성이 커널 내부 구현에
	어떤 영향을 끼치는지 궁금한 사람이라면 이
	연구~\cite{Schimmel:1994:USM:175689} 에 실린 Curt Schimmel 의 고전적
	접근을 한번 봐야 합니다.

\iffalse
\item	Those interested in learning how various types of multi-processor
	hardware
	cache organizations affect the implementation of kernel
	internals should take a look at Curt Schimmel's classic
	treatment of this subject~\cite{Schimmel:1994:USM:175689}.
\fi

\item	마지막으로, Java 사용자라면 Doug Lea 의
	교재~\cite{DougLea1997Textbook,Goetz2007Textbook} 가 큰 도움이
	될겁니다.

\iffalse
\item	Finally, those using Java might be well-served by Doug Lea's
	textbooks~\cite{DougLea1997Textbook,Goetz2007Textbook}.
\fi

\end{enumerate}

하지만, 로우 레벨의, 특히 C 로 구현된 소프트웨어를 위한 병렬적 설계의 기본적
내용에 관심이 있다면, 이 책을 계속 읽으세요!

\iffalse
However, if you are interested in principles of parallel design
for low-level software, especially software written in C, read on!
\fi

\section{Sample Source Code}
\label{sec:howto:Sample Source Code}

이 책은 많은 소스 코드를 인용하고 있고, 많은 경우 그 소스 코드는 이 책의 git
tree 안의 \path{CodeSamples} 디렉토리 안에 있습니다.
예를 들어 UNIX 시스템에서는 다음과 같이 명령을 내릴 수 있을 겁니다:

\iffalse
This book discusses its fair share of source code, and in many cases
this source code may be found in the \path{CodeSamples} directory
of this book's git tree.
For example, on UNIX systems, you should be able to type the following:
\fi

\begin{quote}
	{\scriptsize
	\begin{verbatim}
		find CodeSamples -name rcu_rcpls.c -print
	\end{verbatim}
	}
\end{quote}

이 명령문은
Appendix~\ref{chp:app:``Toy'' RCU Implementations} 에 사용된
\path{rcu_rcpls.c} 파일의 위치를 알려줄 겁니다.
다른 종류의 시스템에서는 나름대로 파일 이름으로 해당 파일의 위치를 알려주는
방법이 있을 겁니다.

\iffalse
This command will locate the file \path{rcu_rcpls.c}, which is called out in
Appendix~\ref{chp:app:``Toy'' RCU Implementations}.
Other types of systems have well-known ways of locating files by filename.
\fi

\section{Whose Book Is This?}
\label{sec:howto:Whose Book Is This?}

\begin{figure*}[tbp]
{
\scriptsize
\begin{verbbox}
  1 git clone git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git
  2 cd perfbook
  3 # You may need to install a font here. See item 1 in FAQ.txt.
  4 make
  5 evince perfbook.pdf & # Two-column version
  6 make perfbook-1c.pdf
  7 evince perfbook-1c.pdf & # One-column version for e-readers
\end{verbbox}
}
\hspace*{1in}\OneColumnHSpace{-0.5in}\theverbbox
\caption{Creating an Up-To-Date PDF}
\label{fig:howto:Creating a Up-To-Date PDF}
\end{figure*}

\begin{figure*}[tbp]
{
\scriptsize
\begin{verbbox}
  1 git remote update
  2 git checkout origin/master
  3 make
  4 evince perfbook.pdf & # Two-column version
  5 make perfbook-1c.pdf
  6 evince perfbook-1c.pdf & # One-column version for e-readers
\end{verbbox}
}
\hspace*{1in}\OneColumnHSpace{-0.5in}\theverbbox
\caption{Generating an Updated PDF}
\label{fig:howto:Generating an Updated PDF}
\end{figure*}

표지에서 이야기했듯, 이 책의 편집자는 Paul E.~McKenney 입니다.
하지만, Paul 은 \co{perfbook@vger.kernel.org} 이메일 리스트를 통한 기여를
받습니다.  이런 기여들은 텍스트 이메일, 책의 \LaTeX{} 소스에 대한 패치,
심지어는 \co{git pull} 요청까지 어떤 형태라도 상관 없습니다.  당신에게
가장 좋은 방법을 사용하세요.

\iffalse
As the cover says, the editor is one Paul E.~McKenney.
However, the editor does accept contributions via the
\href{mailto:perfbook@vger.kernel.org}
{\nolinkurl{perfbook@vger.kernel.org}} email list.
These contributions can be in pretty much any form, with popular
approaches including text emails,
patches against the book's \LaTeX{} source, and even \co{git pull} requests.
Use whatever form works best for you.
\fi

패치를 만들거나 \co{git pull} 요청을 보내기 위해서는,
\url{git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git} 에
있는 이 책의 \LaTeX{} 소스가 필요할 겁니다.
또한, 당연하게도 \co{git} 과 \LaTeX{} 이 필요하겠죠. \co{git} 과 \LaTeX{} 은
대부분의 주요 리눅스 배포본에 포함되어 있습니다.
그 외에도 당신이 사용하고 있는 배포본에 따라 다른 패키지들도 필요할 수
있습니다.
일부 유명한 배포본에 대해 필요한 패키지 목록은 이 책의 \LaTeX{} 소스의
\path{FAQ-BUILD.txt} 파일에 있습니다.

\iffalse
To create patches or \co{git pull} requests, you will need the
\LaTeX{} source to the book, which is at
\url{git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git}.
You will of course also need \co{git} and \LaTeX{}, which are
available as part of most mainstream Linux distributions.
Other packages may be required, depending on the distribution you use.
The required list of packages for a few popular distributions is listed
in the file \path{FAQ-BUILD.txt} in the \LaTeX{} source to the book.
\fi

이 책의 \LaTeX{} 소스 트리를 만들고 보려면 Figure~\ref{fig:howto:Creating a
Up-To-Date PDF} 에 있는 리눅스 커맨드를 사용하세요.  일부 환경에서는
\path{perfbook.pdf} 를 표시하는데 사용되는 \co{evince} 커맨드가 \co{acroread}
라던지 다른 커맨드로 바뀌어야 할 수도 있습니다.  \co{git clone} 커맨드는 PDF 를
최초 만들 때 한번만 수행되면 됩니다. 한번 pdf 를 생성한 이후로는
Figure~\ref{fig:howto:Generating an Updated PDF} 의 커맨드를 수행함으로써
그사이 업데이트된 내용을 얻어오고 업데이트된 내용이 포함된 PDF 를 만들 수
있습니다.  Figure~\ref{fig:howto:Generating an Updated PDF} 의 커맨드는 반드시
Figure~\ref{fig:howto:Creating a Up-To-Date PDF} 에 나온 커맨드가 생성한
\path{perfbook} 디렉토리 안에서 수행되어야 합니다.

\iffalse

To create and display a current \LaTeX{} source tree of this book,
use the list of Linux commands shown in
Figure~\ref{fig:howto:Creating a Up-To-Date PDF}.
In some environments, the \co{evince} command that displays \path{perfbook.pdf}
may need to be replaced, for example, with \co{acroread}.
The \co{git clone} command need only be used the first time you
create a PDF, subsequently, you can run the commands shown in
Figure~\ref{fig:howto:Generating an Updated PDF} to pull in any updates
and generate an updated PDF.
The commands in
Figure~\ref{fig:howto:Generating an Updated PDF}
must be run within the \path{perfbook} directory created by the commands
shown in
Figure~\ref{fig:howto:Creating a Up-To-Date PDF}.
\fi

이 책의 PDF 들은 가끔가다
\url{http://kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html}
과 \url{http://www.rdrop.com/users/paulmck/perfbook/} 에 업로드 됩니다.

\iffalse
PDFs of this book are sporadically posted at
\url{http://kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html}
and at
\url{http://www.rdrop.com/users/paulmck/perfbook/}.
\fi

실제 패치를 보내고 \co{git pull} 요청을 보내는 과정은 리눅스 소스 트리의
\path{Documentation/SubmittingPatches} 에 문서화되어 있는 리눅스 커널의 방식과
유사합니다.
한가지 중요한 필수사항은 각 패치 (\co{git pull} 요청의 경우라면 커밋) 은 반드시
다음과 같은 형태의, 유효한 \co{Signed-off-by:} 라인을 포함해야 합니다:

\iffalse
The actual process of contributing patches and sending \co{git pull}
requests is similar to that of the Linux kernel, which is documented
in the \path{Documentation/SubmittingPatches} file in the Linux source tree.
One important requirement is that each patch (or commit, in the case
of a \co{git pull} request) must contain a valid \co{Signed-off-by:} line,
which has the following format:
\fi

\begin{quote}
	{ \scriptsize
	\co{Signed-off-by: My Name <myname@example.org>}
	}
\end{quote}

\co{Signed-off-by:} 라인을 포함한 패치의 예를 보려면
\url{http://lkml.org/lkml/2007/1/15/219} 를 보십시오.

\iffalse
Please see \url{http://lkml.org/lkml/2007/1/15/219} for an example
patch containing a \co{Signed-off-by:} line.
\fi

\co{Signed-off-by:} 라인은 매우 중요한 의미를 갖는데, 다음과 같은 내용을 당신이
선서한다는 의미입니다:

\iffalse
It is important to note that the \co{Signed-off-by:} line has
a very specific meaning, namely that you are certifying that:
\fi

\begin{enumerate}[label={(\alph*)}]
\item	해당 기여는 모두 또는 부분적으로 저에 의해 만들어졌고, 저는 해당 파일에
	표시된 오픈 소스 라이센스 아래 해당 기여를 제출할 권리를 갖습니다; 또는

\iffalse
\item	The contribution was created in whole or in part
	by me and I have the right to submit it under
	the open source license indicated in the file; or
\fi

\item	해당 기여는 제가 알기로는 적절한 오픈 소스 라이센스 하에 만들어진
	기존의 작업물에 기초하며, 파일에 표시된 대로 저는 그 라이센스 아래 해당
	작업물을 모두 또는 일부분 제가 수정하고 기존과 같은 오픈 소스 라이센스
	아래(제가 다른 라이센스로 제출할 권리를 갖지 않았다면) 제출할 권리를
	갖습니다; 또는

\iffalse
\item	The contribution is based upon previous work
	that, to the best of my knowledge, is covered
	under an appropriate open source License and I
	have the right under that license to submit that
	work with modifications, whether created in whole
	or in part by me, under the same open source
	license (unless I am permitted to submit under
	a different license), as indicated in the file; or
\fi

\item	해당 기여는 제게 (a), (b) 또는 (c) 를 선서해 준 다른 사람에 의해
	제공되었고 저는 이를 수정한 바가 없습니다.

\iffalse
\item	The contribution was provided directly to me by
	some other person who certified (a), (b) or (c)
	and I have not modified it.
\fi

\item	저는 이 프로젝트와 해당 기여가 공적이며 이 기여에 대한 기록 (제가
	기여와 함께 제공한 모든 개인적 정보와 저의 sign-off를 포함하여) 이
	불특정 기간 유지되고 이 프로젝트나 사용된 오픈 소스 라이센스(들) 과
	연관되어 재배포 될 수 있음을 이해하고 동의합니다.

\iffalse
\item	I understand and agree that this project and the
	contribution are public and that a record of the
	contribution (including all personal information
	I submit with it, including my sign-off) is
	maintained indefinitely and may be redistributed
	consistent with this project or the open source
	license(s) involved.
\fi
\end{enumerate}

이건 리눅스 커널에서 사용되는 개발자의 유래에 대한 선서 (DCO) 1.1 과
상당히 유사합니다.
\iffalse

This is quite similar to the Developer's Certificate of Origin (DCO)
1.1 used by the Linux kernel.
\fi

당신은 당신의 진짜 이름을 사용해야만 합니다: 안타깝지만 저는 익명으로 제공된
기여는 받을 수 없습니다.
\iffalse

You must use your real name:  I unfortunately cannot accept pseudonymous or
anonymous contributions.
\fi

이 책은 미국 영어를 사용합니다만, 오픈소스라는 환경상 이 책은 번역이 허용되고,
전 개인적으로 번역을 장려합니다.  이 책에 붙어 있는 오픈 소스 라이센스는
추가적으로, 원한다면 당신이 당신의 번역을 판매할 수도 있게 허용합니다.
번역본의 복사본을 (가능하다면 하드카피로) 보내 주실 것을 부탁드립니다만, 이는
어디까지나 부탁드리는 것이고, 당신이 이미 Creative Commons 와 GPL license 로
갖는 권리에 우선하지 않습니다.  현재 진행중인 번역 작업의 목록을 보려면
\co{FAQ.txt} 파일을 봐 주십시오.  전 최소 한개의 챕터 이상이 이미 모두
번역되었다면 번역 작업이 ``진행 중'' 이라고 여깁니다.

\iffalse
The language of this book is American English, however, the open-source
nature of this book permits translations, and I personally encourage them.
The open-source licenses covering this book additionally allow you
to sell your translation, if you wish.
I do request that you send me a copy of the translation (hardcopy if
available), but this is a request made as a professional courtesy,
and is not in any way a prerequisite to the permission that you already
have under the Creative Commons and GPL licenses.
Please see the \co{FAQ.txt} file in the source tree for a list of
translations currently in progress.
I consider a translation effort to be ``in progress'' once at least one
chapter has been fully translated.
\fi

이 섹션의 시작에서 이야기 했듯, 전 이 책의 편집자입니다.
하지만, 당신이 기여를 하기로 하면, 이것은 당신의 책이기도 합니다.
이제, Chapter~\ref{chp:Introduction}, introduction 을 시작합니다.

\iffalse
As noted at the beginning of this section, I am this book's editor.
However, if you choose to contribute, it will be your book as well.
With that, I offer you Chapter~\ref{chp:Introduction}, our introduction.
\fi
