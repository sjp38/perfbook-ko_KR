% together/hash.tex
% SPDX-License-Identifier: CC-BY-SA-3.0

\section{Hashing Hassles}
\label{sec:together:Hashing Hassles}

이 섹션은 해시 테이블을 다룰 때에 나타날 수 있는 몇가지 문제들을 알아봅니다.
이런 문제들은 많은 다른 탐색을 하는 구조체들에서도 역시 나타날 수 있음을 알아
두시기 바랍니다.
\iffalse

This section looks at some issues that can arise when dealing with
hash tables.
Please note that these issues also apply to many other search structures.
\fi

\subsection{Correlated Data Elements}
\label{sec:together:Correlated Data Elements}

이 상황은
Section~\ref{sec:together:Correlated Fields} 에서의 것과 비슷합니다:
우린 두개 이상의 원소들의 연관된 시야를 필요로 하는 해시 테이블을 가지고
있습니다.
이 원소들은 함께 업데이트 되고, 첫번째 원소의 기존 버전과 함께 다른 원소들의
새로운 버전을 보지는 않고 싶습니다.
예를 들어, Schr\"odinger 는 그의 in-memory 데이터베이스에 그의 모든 동물들에
가족을 추가시키려 합니다.
Schr\"odinger 는 결혼과 이혼이 순간적으로 일어나지는 않음을 알고 있지만, 그는
전통주의자이기도 합니다.
이와 같이, 그는 그의 데이터베이스가 신부는 이제 결혼했지만, 신랑은 그렇지 않은
경우, 또는 그 반대의 경우를 원하지 않습니다.
달리 말하자면, Schr\"odinger 는 그의 데이터베이스에 wedlock (역자 주: 결혼에
관련된 락) 에 일관적인 데이터 열람이 가능하기를 원합니다.
\iffalse

This situation is analogous to that in
Section~\ref{sec:together:Correlated Fields}:
We have a hash table where we need correlated views of two or more of
the elements.
These elements are updated together, and we do not want to see an old
version of the first element along with new versions of the other
elements.
For example, Schr\"odinger decided to add his extended family to his
in-memory database along with all his animals.
Although Schr\"odinger understands that marriages and divorces do not
happen instantaneously, he is also a traditionalist.
As such, he absolutely does not want his database ever to show that the
bride is now married, but the groom is not, and vice versa.
In other words, Schr\"odinger wants to be able to carry out a
wedlock-consistent traversal of his database.
\fi

한가지 방법은 시퀀스 락
(Section~\ref{sec:defer:Sequence Locks} 를 참고하세요)
을 사용해서 wedlock 에 관계된 update 들이 \co{write_seqlock()} 의 보호 아래
행해지도록 하고, wedlock 일관성을 필요로 하는 read 들은 \co{read_seqbegin()} /
\co{read_seqretry()} 루프 아래 행해지도록 하는 겁니다.
시퀀스 락들은 RCU 보호의 대체품이 안미을 알아두시기 바랍니다:
시퀀스 락은 동시적인 수정들에 대해 데이터를 보호하지만, 동시적인 삭제들로부터
데이터를 보호하기 위해선 RCU 가 여전히 필요합니다.

이 방법은 연관된 원소들의 갯수가 작고, 이 원소들을 읽는 시간이 짧으며, 업데이트
되는 빈도가 적을 때 상당히 잘 동작합니다.
그렇지 않다면, 업데이트들은 읽기 쓰레드들이 결코 완료될 수 없을 정도로
업데이트들이 자주 일어날 수도 있을 겁니다.
Schr\"odiger 는 그의 가장 덜 정상적인 동물들이라 해도 이런 문제가 생길 수 있을
정도로 빠르게 결혼과 이혼을 행하지는 않을 것으로 예상한다고 해도, 그는 이
문제가 다른 상황에서도 역시 일어날 수 있음을 깨닫고 있습니다.
이 읽기 쓰레드 starvation 문제를 없애는 한가지 방법은 읽기 쓰레드들이 너무 많은
재시도를 행하게 된다면 update-side 기능들을 사용하는 것입니다만, 이는 성능과
확장성을 떨어뜨릴 수 있습니다.
\iffalse

One approach is to use sequence locks
(see Section~\ref{sec:defer:Sequence Locks}),
so that wedlock-related updates are carried out under the
protection of \co{write_seqlock()}, while reads requiring
wedlock consistency are carried out within
a \co{read_seqbegin()} / \co{read_seqretry()} loop.
Note that sequence locks are not a replacement for RCU protection:
Sequence locks protect against concurrent modifications, but RCU
is still needed to protect against concurrent deletions.

This approach works quite well when the number of correlated elements is
small, the time to read these elements is short, and the update rate is
low.
Otherwise, updates might happen so quickly that readers might never complete.
Although Schr\"odinger does not expect that even his least-sane relatives
will marry and divorce quickly enough for this to be a problem,
he does realize that this problem could well arise in other situations.
One way to avoid this reader-starvation problem is to have the readers
use the update-side primitives if there have been too many retries,
but this can degrade both performance and scalability.
\fi

또한, 만약 update-side 기능들이 너무 자주 사용된다면, 락 경쟁으로 인해 낮은
성능과 확장성이 초래될 것입니다.
이를 막을 수 있는 한가지 방법은 per-element 시퀀스 락을 두고, 결혼 상태를
업데이트 할 때 두 배우자의 락을 모두 잡도록 하는 것입니다.
읽기 쓰레드들은 두 멤버에 연관된 결혼 상태의 모든 변경사항에 대한 안정적인
시야를 얻기 위해 두 배우자들의 락들에 대해 재시도 루프를 행할 수 있습니다.
이는 높은 결혼과 이혼 빈도에 의한 경쟁을 없앨 수 있습니다만, 데이터베이스에
대한 한번의 스캔 동안의 모든 결혼 상태들에 대한 안정적인 시야를 얻는 과정이
복잡해 집니다.
\iffalse

In addition, if the update-side primitives are used too frequently,
poor performance and scalability will result due to lock contention.
One way to avoid this is to maintain a per-element sequence lock,
and to hold both spouses' locks when updating their marital status.
Readers can do their retry looping on either of the spouses' locks
to gain a stable view of any change in marital status involving both
members of the pair.
This avoids contention due to high marriage and divorce rates, but
complicates gaining a stable view of all marital statuses during a
single scan of the database.
\fi

원소 그룹짓기가 결혼 상태가 그렇기를 바라듯이 잘 정의되어 있고 영속적이라면,
데이터 원소에 주어진 그룹의 멤버들로의 링크를 가리키는 포인터를 추가하는 것도
한가지 방법입니다.
그렇게 되면 읽기 쓰레드들은 첫번째 멤버와 같은 그룹의 모든 데이터 원소들에
접근하기 위해서 이 포인터들을 따라가면 됩니다.

버전 넘버를 사용하는 다른 방법은 흥미있는 독자들을 위한 몫으로 남겨두겠습니다.
\iffalse

If the element groupings are well-defined and persistent, which marital
status is hoped to be,
then one approach is to add pointers to the data elements to link
together the members of a given group.
Readers can then traverse these pointers to access all the data elements
in the same group as the first one located.

Other approaches using version numbering are left as exercises for the
interested reader.
\fi

\subsection{Update-Friendly Hash-Table Traversal}
\label{sec:together:Update-Friendly Hash-Table Traversal}

해시 테이블의 모든 원소들에 대한 통계적 스캐닝이 필요하다고 생각해 봅시다.
예를 들어, Schr\"odinger 는 모든 동물들에 대해 평균적인 신장 대비 체중 비율을
구하고 싶어할 수 있습니다.\footnote{
	왜 그런 숫자가 필요하죠?
	절 때리세요!
	하지만 일반적인 그룹 통계는 유용한 경우가 많습니다.}
더 나아가서 Schr\"odinger 가 이 통계를 위한 스캐닝이 진행되는 사이에 이 해시
테이블에 추가되고 삭제된 동물들로 인한 작은 에러정도는 무시하고자 한다고 생각해
봅시다.
Schr\"odinger 는 동시성을 제어하기 위해 무엇을 해야 할까요?

한가지 방법은 통계를 위한 스캐닝을 RCU read-side 크리티컬 섹션으로 감싸는
것입니다.
이는 업데이트들이 스캐닝에 과도하게 훼방을 놓지 않으면서 동시적으로 진행되는
것을 가능하게 합니다.
특히, 이 스캐닝은 업데이트를 가로막지 않고 그 반대 역시 마찬가지여서, 설령 매우
높은 업데이트 빈도가 있다 해도 매우 많은 양의 원소들을 담고 있는 해시
테이블들에 대한 스캐닝을 우아하게 지원합니다.
\iffalse

Suppose that a statistical scan of all elements in a hash table is
required.
For example, Schr\"odinger might wish to compute the average
length-to-weight ratio over all of his animals.\footnote{
	Why would such a quantity be useful?
	Beats me!
	But group statistics in general are often useful.}
Suppose further that Schr\"odinger is willing to ignore slight
errors due to animals being added to and removed from the hash
table while this statistical scan is being carried out.
What should Schr\"odinger do to control concurrency?

One approach is to enclose the statistical scan in an RCU read-side
critical section.
This permits updates to proceed concurrently without unduly impeding
the scan.
In particular, the scan does not block the updates and vice versa,
which allows scan of hash tables containing very large numbers of
elements to be supported gracefully, even in the face of very high
update rates.
\fi

\QuickQuiz{}
	하지만 이 스캐닝은 크기 재조정이 되고 있는 크기 재조정 가능한 해시
	테이블에 대해서는 어떻게 동작하나요?
	그런 경우, 기존의 해시테이블도 새로운 해시테이블도 해당 해시 테이블에
	모든 원소들을 담고 있다고 보장될 수 없는데요!
	\iffalse

	But how does this scan work while a resizable hash table
	is being resized?
	In that case, neither the old nor the new hash table is
	guaranteed to contain all the elements in the hash table!
	\fi
\QuickQuizAnswer{
	사실입니다,
	Section~\ref{sec:datastruct:Non-Partitionable Data Structures}
	에서 이야기된 크기 재조정 가능한 해시 테이블들은 크기 재조정 진행 중에
	모두 스캔 될 수 없습니다.
	이를 위한 한가지 간단한 방법은 \co{hashtab} 구조체의 \co{->ht_lock} 을
	스캐닝 중에 잡는 것입니다만, 이 방법은 두개 이상의 스캔이 동시에
	진행되지 못하도록 합니다.

	또다른 방법은 크기 재조정 진행 중에는 업데이트들이 새로운 해시
	테이블만이 아니라 기존의 것도 변형시키도록 하는 것입니다.
	이는 스캐닝이 기존의 해시 테이블에서도 모든 원소들을 볼 수 있도록
	합니다.
	이를 구현하는 것은 독자 여러분의 몫으로 남겨두겠습니다.
	\iffalse

	True, resizable hash tables as described in
	Section~\ref{sec:datastruct:Non-Partitionable Data Structures}
	cannot be fully scanned while being resized.
	One simple way around this is to acquire the
	\co{hashtab} structure's \co{->ht_lock} while scanning,
	but this prevents more than one scan from proceeding
	concurrently.

	Another approach is for updates to mutate the old hash
	table as well as the new one while resizing is in
	progress.
	This would allow scans to find all elements in the old
	hash table.
	Implementing this is left as an exercise for the reader.
	\fi
} \QuickQuizEnd
